---
title: "Autoregressive"
author: "Chris Simoes"
date: "4/7/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Spatial Correction 2D Autoregressive

Here I am modeling for spatial correction. The key is to calculate the R matrix which is a Kronecker product between correlation rows and correlation columns.<br>
Simulating trial with 4 varieties and 4 replications.

```{r spatial correction, echo = TRUE}

#Creating a matrix
library(agricolae)
T=matrix("NA",16,4)
trt <- c("tr1","tr2","tr3","tr4")
rep <- 4
myRCBD <- design.rcbd(trt,r=rep, seed=-513, serie=1)
book2<- zigzag(myRCBD)

# Creating the trial matrix
j=1
for( i in 1:nrow(book2)){
  T[i,1] <- paste("",book2[i,3],sep="")
  T[i,3] <- book2[i,2]
  T[i,2] <- j
  j=j+1
  if(j>4){
    j=1
  }
}

T <-  noquote(T[order(T[,1]),]) # Sorting by treatment in this case genotypes

# Incidence Matrix
Xf=matrix(0,16,4)
Xf[,1]=c(1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0) # Variet 1 in each replication
Xf[,2]=c(0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0) # Variet 2 in each replication
Xf[,3]=c(0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0) # Variet 3 in each replication
Xf[,4]=c(0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1) # Variet 4 in each replication
Xf

# calculating the rank of the matrix
Matrix::rankMatrix(Xf) # Check that the rank is 4 and Xf has 4 columns. It works when getting the inverse matrix.

# Calculating X'X
XftXf = t(Xf)%*%(Xf)
XftXf

#Simulating data for each tretament
beta2=c(100,110,115,120) # this is a vector with 4 means for each variety
y=Xf%*%beta2+rnorm(16,0,2) # here I am simulating 16 values for y
Tnew <- noquote(data.frame(cbind(T[,1:3], y)))
colnames(Tnew) <- c("Treatment", "Col", "Row", "Yield")

# Function to get correlations 
createCorrelation <- function(Dat){
  CorM = diag(1,4,4)
  for(i in 1:(nrow(CorM)-1)){
  r1 <- data.frame(as.numeric(Tnew[Dat==i,4]))
  j=i+1
  while(j <= nrow(CorM)){
    r2 <- data.frame(as.numeric(Tnew[Dat==j,4]))
    co1 <- var(r1,r2)/sqrt(var(r1)*var(r2)) #correlation
    CorM[i,j] = co1**(j-1) # the power increases with the distance.
    CorM[j,i] = co1**(j-1)
    j=j+1
  }
  
  }
  return(CorM)
}

RCM = createCorrelation(Tnew$Row) #Calling correlation per row
CCM = createCorrelation(Tnew$Col) #Calling correlation per col

# Calculating variance
p=rep(1,nrow(Tnew)) #vector
s = as.numeric(Tnew$Yield)
varS = (t(s - mean(s))%*%(s - mean(s)))/(length(s)-1)

# Calculating the autoregressive vector
# varS * RCM %x% CCM (where %x% means kronecker product)
R = varS[1] * RCM %x% CCM 

corrected <- R %*% p #Corrected values per plot

finalTable <- cbind(Tnew, corrected)
knitr::kable(finalTable)

```
